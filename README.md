# JS-
note for js advanced

# 正则表达式

## 字符集
* **其他简写**
	- 要匹配一位小写字母:[a-z]
	- 要匹配一位大写字母:[A-Z]
	- 要匹配一位字母:[A-Za-z]
	- 要匹配一位字母或数字:[0-9A-Za-z]
	- 要匹配一位汉字:[\u4e00-\u9fa5]
	- 要匹配一位数字:\d 等效于[0-9]
	- 要匹配一位字母 数字或 _:\w 等效于 [0-9A-Za-z_]
	- 要匹配一位空字符:\s 可匹配空格,制表符Tab等空白
	- 要匹配所有的文字(通配符): .

## 数量词
* **数量词包括两大类**
	- 有明确数量边界的数量词
	    1. 字符集{n}    表示字符集必须重复n次，不能多也不能少
	    2. 字符集{n,m}  表示字符集至少重复n次，最多重复m次，比如: \d{4,6} 表示4到6位数字
	    3. 字符集{n,}  表示字符集匹配的内容至少重复n次，多了不限，比如：\d{6,} 表示6位以上数字
	    
	- 没有明确数量边界的数量词
	    1. \*  可有可无，多了不限
	    2. \?  可有可无，最多一次
	    3. \+  至少一次，多了不限

## 选择和分组
* **选择**
	- 选择，是指在多个子规则中选其一匹配
	- 今后，只要在多个子规则中选其一匹配时，就用选择
	- 如何: 子规则1|子规则2
	- “|” 选择符只分左右，不考虑单个字符
* **分组**
	- 分组，将多个子规则视为一组，再和分组外的规则匹配
	- 只要希望将多个子规则视为一个整体，再和其它规则匹配时，就用分组
	- 如何： 其它规则 (多个子规则)
	- 比如： 我(草|cao) , 我 ([草艹槽]|cao)

## 指定匹配位置
* **位置字符**
	- 如果只希望匹配特殊位置上的关键词时，就可用特殊符号表示特殊位置。
	- 包括:
		1. ^  表示字符串开头
		2. $  表示字符串结尾
		3. \b 表示单词边界,可匹配:空格,标点符号,字符串开头和结尾等可将一个单词与其他单词分割开的符号
		
## js中的正则
* **String 中的正则 API**
	- 查找一个关键词的位置:**indexOf**
	```
		//在str中,从starti位置开始,默认从0开始,如果找不到返回-1
		var i = str.indexOf("关键词"[,stari]);
		//问题:不支持正则表达式,只能查找一个固定的关键词
		
	```
	- 用正则表达式模糊查找多种关键词:**search**
	```
		var i = str.search(/正则/i);
		/*在str中从开头位置开始,找第一个符合正则表达式的关键词的位置
		  返回值:如果找到,返回符合关键词第一个字符的位置下标,如果没找到,返回-1
		*/

	```
	- 查找关键词的内容:**match**
	```
		var i = str.match(/正则/[ig]);
		/*在str中查找第一个符合正则表达式要求的敏感词
			返回值:关联数组:["0":"敏感词","index":位置]
			问题:加g后,返回的数组不在有index位置,而由所有的敏感词的内容组成返回值
		*/
	```
	- 查找关键词的内容和位置: **replace**
	```
		//1. 简单替换:将符合正则表达式的敏感词都替换成为统一的新值
			var str = str.replace(/正则/ig,"新值");
		//2. 高级替换:根据敏感词的不同,动态选择不同的新值替换
			var str = str.replace(/正则/ig,function(kword){
				return 新值;
			});
	```
	- 切割字符串 **split**
	```
		//简单切割
			var arr = str.split("切割符");
		//复杂切割
			var arr = str.split(/正则/);
	```

* **RegExp 对象**
	- 创建正则表达式对象
		1. var reg = /正则/ig;
		2. var reg = new RegExp("正则表达式","ig");
	- 功能
		1. 验证
		```
			//只要找到包含的,就算成功
				var bool = reg.test(str);
			/*问题:test默认只要找到部分匹配就返回true
			  解决:正则前面加 ^ ,后面加 $; 意为必须从头到尾完整匹配才行
			*/
		```
		2. 查找
		```
			//即查找每个关键词的内容,又查找每个关键词的位置
				var arr = reg.exec(str);
			/*返回值:
			  arr:["0":"敏感词","index":下标位置]
			*/
		```
----------
# 数组
## 数组API
* **查找元素的位置**
	```
		var i = arr.indexOf(元素值,starti);
	```

* **判断数组是否由规定的内容组成**
	- 判断是否所有元素都符合要求 **every**
	```
		var bool = arr.every(function(ele,i,arr){
			//ele:当前元素值
			//i:当前位置
			//arr:当前数组对象
			return 根据ele,i,arr判断当前元素是否符合要求;
		});
	```
	- 判断是否包含符合要求的元素 **some**
	```
		var bool = arr.some(function(ele,i,arr){
			return 判断条件;
		});
	```
* **遍历**
	- 对原数组中每个元素执行相同的操作 **forEach**
	```
		arr.forEach(function(ele,i,arr){
			//对当前元素执行相同的操作
		});
	``` 
	- 依次取出原数组中每个元素值,执行相同操作后,放入新数组中返回 **map**
	```
		var evens = arr.map(function(ele,i,arr){
			//操作
		});
	```
	- 只关心内容,不关心位置和顺序 **for of**
	```
		for(var ele of arr){
			//ele:arr的值
		}
	```
	** 总结:只是使用最佳选择
		1. 遍历索引数组:forEach , for
		2. 遍历数组对象:for
		3. 遍历对象和关联数组:for in
		4. 保护原数组,并生成新数组:map ---只有索引数组
		5. 遍历对象和关联数组 for of
* **过滤和汇总**
	- 过滤:复制出原数组中符合条件的元素,组成新的子数组,原数组保持不变 **filter**
	```
		var subarr = arr.filter(function(ele,i,arr){
			return 判断条件;
		});
	```
	- 汇总:对数组中的所有数组进行统计和分析,得出最终结论
	```
		var result = arr.reduce(function(prev,ele,i,arr){
			//prev是截止目前的临时汇总值
			return prev;
		});
	```

----------
